```{r, echo=FALSE}

#| code-fold: true
#| warning: false

source("../src/utils/utils.r", encoding = 'UTF-8')

```

# Aproximaciones por nivel

En las series de tiempo (datos secuenciales) una de las características principales es su natural estructura compleja de *autocorrelación* que implica que las observaciones no son independientes. En general, presentan patrones de tendencia, ciclicidad o autocorrelación que requieren un entendimiento profundo para poder analizar correctamente la serie, ya sea para realizar descripción e inferencia acerca de su estructura o para generar predicciones acerca de valores futuros.

Los modelos de espacio de estados (bayesianos dinámicos) nos permite modelar la estructura de una serie de tiempo de forma modular, además:

-   Mayor flexibilidad en cuanto a las estructuras que podemos usar, y cómo usar información acerca de la dinámica de la serie de tiempo (incluyendo aspectos de modelos ARIMA).
-   Una forma estándar de tratar con valores faltantes, series irregulares, o varias observaciones contemporáneas.
-   Una forma estándar de producir pronósticos puntuales, en intervalos, o por distribuciones.
-   Una forma estándar de permitir que el modelo se adapte en el tiempo a cambios estructurales (por ejemplo, cambios de patrones de estacionalidad, efectos diferentes de covariables, etc.)

Por otro lado, regularmente las series de tiempo pueden estar desagregadas por diversos atributos específicos de interés para el investigador. Tales atributos podrían desagregarse a su vez en categrorías o subcategorías más detalladas, esto es, categorías anidadas en categorías de grupos de mayor tamaño, por lo que a esta estructura de agregación jerárquica en las series de tiempo le llamamos naturalmente **"Series de Tiempo Jerárquicas"**, que usualmente resultan a causa de las divisiones geográficas.

Una estructura de agregación más compleja aún surge cuando podemos utilizar dos categorías jerárquicas juntas, e.g. jerarquías por producto y por región geográfica. En este caso se le conoce como **"Series de Tiempo Agrupadas**

Para complementar e ilustrar nuestra investigación sobre Predicción en Modelos de Series de Tiempo Jerárquicas, se decidió utilizar siguiente dataset de Kaggle [Tabular Playground Series Sep2022](https://www.kaggle.com/competitions/tabular-playground-series-sep-2022/data) El objetivo consiste en predecir un año completo de ventas para 4 artículos de 2 tiendas en 6 distintos países, por lo que, de acuerdo a lo comentado anteriormente, es una serie de tiempo con estructura jerárquica. (ver sección 1 para ampliar información sobre el _dataset_). El siguiente diagrama nos permite visualizar tal estructura:

![](figuras/series_de_tiempo_hierarchical.jpg)

Usualmente generamos predicciones desagregadas a partir de series de tiempo desagregadas y requerimos que tales predicciones se adicionen en la misma forma que la estructura en los datos. En nuestro ejemplo, las predicciones de cada tienda se adicionan para generar la predicción de cada país y éstas a su vez para generar la predicción de ventas total.

Nuestro objetivo es presentar y discutir los métodos de predicción para colecciones de series de tiempo jerárquicas bajo el reto que tales predicciones guarden congruencia a través de la estructura de agregación.

{{< pagebreak >}}

## Series de Tiempo Jerárquicas

Esencialmente, estas series se organizan en una estructura por niveles, siendo el nivel 0 la jerarquía más alta, es decir, el nivel de mayor agregación de los datos.

La siguiente figura nos permitira conceptualizar de forma intuitiva las estructuras jerárquicas y servirá como base para construir las ecuaciones y notación necesaria.

![](figuras/diagram_hierarchical.png)

```{r, fig.cap="Figure: Diagrama de árbol de una estructura jerárquica de 2 niveles", eval=FALSE, echo = FALSE}

#| code-fold: true
grViz("
digraph {
  graph [ranksep = 0.7, fontsize = 11]
  node [shape = circle, style = filled, width = 1, fontcolor = blue, fontname = Helvetica, fontsize = 19]
  node [color = green]
    y  [label = Total]
  node [color = steelblue]
    A  [label = A]
    AA [label = AA]
    AB [label = AB]
    AC [label = AC]
  node [color = yellow]
    B  [label = B]
    BA [label = BA]
    BB [label = BC]
  edge [minlen = 2, color = gray, arrowsize = 0]
    y -> A
    y -> B
    A -> AA
    A -> AB
    A -> AC
    B -> BA
    B -> BB
    
{ rank = same; A; B }
{ rank = same; AA; AB; AC; BA; BB }
}
", width = 600, height = 300
)

```


Denotemos la $t$th observación por $y_{t}$ donde $t=1,...,T$. En el gráfico anterior podemos osbervar que la estructura jerárquica nos muestra que el Total está desagregado en 2 series $A$ y $B$ en el nivel 1, que a su vez se desagregan en 3 y 2 series respectivamente en el nivel más bajo. Esto implica que tenemos 8 (1, 2, 5) series, con  5 en el último nivel de la jerarquía.

Para cualquier tiempo $t$, las observaciones en el último nivel inferior de la jerarquía deben sumar con las observaciones de las series superiores. Por tanto, podemos construir ecuaciones de agregación restricta (por llamarles de alguna forma):

$$y_{t}=y_{AA,t}+y_{AB,t}+y_{AC,t}+y_{BA,t}+y_{BB,t}$$

equivalente a $$y_{t}=y_{A,t}+y_{B,t}$$

con $y_{A,t}=y_{AA,t}+y_{AB,t}+y_{AC,t}$ y $y_{B,t}=+y_{BA,t}+y_{BB,t}$

Por practicidad, es recomendable que utilicemos una notación matricial (por ser más compacta). Básicamente, buscamos una matriz que induzca la forma en que las series inferiores deben agregarse. Para ello, contruimos una matriz de acumulación $S$ de orden $n \times m$ de la siguiente forma (con base a la estructura de nuestro ejemplo):


$$
\begin{bmatrix}
    y_{t} \\
    y_{A,t} \\
    y_{B,t} \\
    y_{AA,t} \\
    y_{AB,t} \\
    y_{AC,t} \\
    y_{BA,t} \\
    y_{BB,t}
  \end{bmatrix}
  =
  \begin{bmatrix}
    1 & 1 & 1 & 1 & 1 \\
    1 & 1 & 1 & 0 & 0 \\
    0 & 0 & 0 & 1 & 1 \\
    1  & 0  & 0  & 0  & 0  \\
    0  & 1  & 0  & 0  & 0  \\
    0  & 0  & 1  & 0  & 0  \\
    0  & 0  & 0  & 1  & 0  \\
    0  & 0  & 0  & 0  & 1
  \end{bmatrix}
  \begin{bmatrix}
    y_{AA,t} \\
    y_{AB,t} \\
    y_{AC,t} \\
    y_{BA,t} \\
    y_{BB,t}
  \end{bmatrix}
$$
cuya ecuación queda definida por:
$$\boldsymbol{y}_t=\boldsymbol{S}\boldsymbol{b}_{t},$$

donde:
> $y_t$: vector $n$-dimensional con todas las observaciones de la jerarquía en el tiempo $t$
> $\boldsymbol{S}$: matriz de acumulación
> $\boldsymbol{b}_t$: es un vector $m$-dimensional de las observaciones en el nivel último inferior de la jerarquía.

*¿Qué representa nuestra matriz, cómo induce las relaciones de jerarquía, cómo se construye?*

1. La primer fila de la matriz representa la ecuación (1), la serie en el nivel más alto de la jerarquía
2. En este caso, la segunda y tercer fila representan la siguiente ecuación correspondientes a las series $A$ y $B$ para el nivel 2 de nuestro ejemplo
$\vdots$ (similar al nivel 2, se construyen niveles adicionales inferiores hasta llegar  al penúltimo nivel)
n. El último nivel deberá ser presentado por una matriz identidad $I_m$.


**Ejemplo. Kaggle Tabular Playground Series - Sep 2022**

Como mencionamos en la sección 1, los datos corresponden a 6 países que a su vez poseen 2 tiendas (que compiten) y las cuales comercializan 4 productos de interés para los accionistas. El área de desarrollo comercial y presupuesto está interesada en conocer el valor de las ventas totales para 2021 en la región Europea; así mismo, desean conocer los ventas por producto para determinar el nivel de producción requerido por país garantizando que no exista desabasto ni sobreinventario; finalmente, es requerido analizar el la rentabilidad que se espera por tienda.


Lo primero que haremos es construir nuestra base  

```{r}
sales_m <- sales |>
    mutate(t = (year(date)-year(min(date)))*12 + (month(date)-month(min(date)))) |>
    mutate(date = yearmonth(date)) |>
    group_by(date,t,country,store,product) |>
    summarise(num_sold = sum(num_sold,na.rm = TRUE)) |>
    ungroup() |>
    as_tsibble(index = date,key = c(country,store,product))
```


```{r}
sales_m |>
  aggregate_key(country / store /product, num_sold = sum(num_sold,na.rm=TRUE)/1000) |>
  filter(is_aggregated(store)) |>
  autoplot(num_sold) +
  labs(x = "Mes/Año" , y = "Ventas (miles)",title = "Ventas totales y por país") +
  facet_wrap(vars(country), scales = "free_y", ncol = 3) +
  theme(legend.position = "none")

```



```{r}

sales_m |>
  aggregate_key(country / store /product, num_sold = sum(num_sold,na.rm=TRUE)/1000) |>
  filter(country == "Poland" | country == "Germany") |>
  #filter(is_aggregated(store)) |>
  autoplot(num_sold) +
  labs(x = "Mes/Año" , y = "Ventas (miles)",title = "Ventas de Polonia por tienda/producto") +
  facet_wrap(vars(country,store), scales = "free_y", ncol = 3) +
  theme(legend.position = "none")

```



```{r}

sales_m |>
  aggregate_key(country / store /product, num_sold = sum(num_sold,na.rm=TRUE)/1000) |>
  filter(is_aggregated(product),is_aggregated(store)) |>
  select(-product,-store) |>
  mutate(country = factor(country)) |>
  gg_season(num_sold) +
  facet_wrap(vars(country), nrow = 2, scales = "free_y")+
  labs(x = "Mes",y = "Ventas (miles)")

```































## Series de Tiempo Agrupadas

En este caso, los datos no tienen una forma jerárquica de desagregarse naturalmente



![](figuras/diagram_grouped.png)
```{r, fig.cap="Figure: Diagrama de árbol de una estructura agrupada de 2 niveles", eval = FALSE, echo = FALSE}

#| code-fold: true
grViz("
digraph {
  graph [ranksep = 0.7, fontsize = 11]
  node [shape = circle, style = filled, width = 1, fontcolor = blue, fontname = Helvetica, fontsize = 19]
  node [color = green]
    T1  [label = Total]
    T2  [label = Total]
  node [color = steelblue]
    A  [label = A]
    AX [label = AX]
    AY [label = AY]
  node [color = yellow]
    B  [label = B]
    BX [label = BX]
    BY [label = BY]
  node [color = steelblue]
    X  [label = X]
    AX2 [label = AX]
    BX2 [label = BX]
  node [color = yellow]
    Y  [label = Y]
    AY2 [label = AY]
    BY2 [label = BY]
  edge [minlen = 2, color = gray, arrowsize = 0]
    T1 -> A
    T1 -> B
    T2 -> X
    T2 -> Y
    A -> AX
    A -> AY
    B -> BX
    B -> BY
    X -> AX2
    X -> BX2
    Y -> AY2
    Y -> BY2

    
{ rank = same; A; B }
{ rank = same; AX; AY; BX; BY; AX2; AY2; BX2; BY2}
}
", width = 600, height = 300
)

```















## Estructura Mixta Jerárquica y Agrupada

Ahora bien, es posible que en algunos casos los factores de desagregación estén tanto anidados como cruzados (intersectados) al mismo tiempo, por lo que nuestra estructura es mixta, jerárquica y agrupada al mismo tiempo.

Continuemos con nuestro caso de estudio de los datos de Ventas de productos en países europeos (Kaggle), los datos pueden desagregarse en los 4 productos sin necesidad de anidarse en cualquiera de las otras variables, país o tienda, esto es, podemos analizar nuestros datos o hacer predicciones por producto para toda la región europea con presencia comercial, pero también es posible realizar esto por cada país y por cada tienda. Se define esta estructura como **anidación** de geografía jerárquica **cruzada** o "intersectada" con el producto.

Continuando con el uso del paquete de los autores `fpp3`, lo anterior se implementa combinando factores utilizando la función `aggregate_key()`.



```{r}
sales_m |>
  aggregate_key((country / store) * product, num_sold = sum(num_sold,na.rm=TRUE)/1000) |>
  filter(is_aggregated(country), is_aggregated(store), !is_aggregated(product)) |>
  autoplot(num_sold) +
  labs(x = "Mes/Año" , y = "Ventas (miles)",title = "Ventas totales por producto") +
  facet_wrap(vars(product), scales = "free_y", ncol = 2) +
  theme(legend.position = "none")
```







```{r}
sales_m |>
  aggregate_key((country / store) * product, num_sold = sum(num_sold,na.rm=TRUE)/1000) |>
  filter(!is_aggregated(country), is_aggregated(store), !is_aggregated(product)) |>
  autoplot(num_sold) +
  labs(x = "Mes/Año" , y = "Ventas (miles)", title = "Ventas totales: por producto y país") +
  facet_wrap(vars(country), scales = "free_y", ncol = 3) +
  theme(legend.position = "none")
```





## Enfoque ascendente (bottom-up)

## Enfoque descendente (top-down)

Bajo este enfoque, el método consiste en generar las predicciones para el Total de las series $y_t$ para postreriormente desagregarlas bajo la secuencia jerárquica.

### Proporciones históricas promedio (**Average historical proportions**)

### Proportions of the historical averages

### Forecast proportions

## Enfoque *middle-out*

## *Mapping Matrices*

## Enfoque de Reconciliación Óptima

Sin profundizar mucho en este tema, haremos un esbozo sobre este enfoque, en el que buscamos la matriz $G$ que minimice el error de predicción para el conjunto de predicciones coherentes que hayamos realizado.

Supongamos que logramos generar predicciones coherentes bajo la ecuación (revisada en la sección anterior):

$$\tilde{\boldsymbol{y}}_h=\boldsymbol{S}\boldsymbol{G}\hat{\boldsymbol{y}}_h$$

| Col1 | Col2 | Col3 |
|------|------|------|
|      |      |      |
|      |      |      |
|      |      |      |
